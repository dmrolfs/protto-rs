//! # proto_convert
//!
//! Automatically derive conversions between Rust structs and Protocol Buffer messages.
//!
//! ## Quick Start
//!
//! Add to your `Cargo.toml`:
//! ```toml
//! [dependencies]
//! proto_convert = "0.2"
//!
//! [build-dependencies]
//! proto_convert = { version = "0.2", features = ["build"] }
//! ```
//!
//! In your `build.rs`:
//! ```rust,no_run
//! fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let proto_files = vec!["proto/my_service.proto".to_string()];
//!     proto_convert::generate_proto_metadata(&proto_files)?;
//!     Ok(())
//! }
//! ```
//!
//! In your code:
//! ```rust,ignore
//! use proto_convert::{ProtoConvert, include_field_metadata};
//!
//! // Include the generated metadata
//! include_field_metadata!();
//!
//! #[derive(ProtoConvert)]
//! struct User {
//!     name: String,           // Required in proto
//!     email: Option<String>,  // Optional in proto - automatically detected
//! }
//! ```

#![doc(html_root_url = "https://docs.rs/proto_convert/0.2.0")]

// re-export the derive macro
pub use proto_convert_derive::*;

// re-export build functions when build feature is enabled
#[cfg(feature = "build")]
pub use proto_convert_build::*;

/// Include field metadata generated at build time.
///
/// This macro injects the metadata generated by `proto_convert_build::generate_proto_metadata()`
/// into your code. It must be called before using `#[derive(ProtoConvert)]` on structs that
/// need build-time field optionality detection.
///
/// The macro works by including a file generated in `$OUT_DIR/proto_field_metadata.rs` during
/// the build process.
///
/// # Example
///
/// ```rust,ignore
/// use proto_convert::{ProtoConvert, include_field_metadata};
///
/// // Include the generated metadata - this must come first
/// include_field_metadata!();
///
/// #[derive(ProtoConvert)]
/// struct MyStruct {
///     required_field: String,
///     optional_field: Option<String>,
/// }
/// ```
///
/// # Build Script Setup
///
/// Your `build.rs` should call `generate_proto_metadata()`:
///
/// ```rust,no_run
/// fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let proto_files = vec!["proto/service.proto".to_string()];
///     proto_convert::generate_proto_metadata(&proto_files)?;
///     Ok(())
/// }
/// ```
///
/// # Feature Requirements
///
/// This macro requires the `meta-file` feature to be enabled:
///
/// ```toml
/// [dependencies]
/// proto_convert = { version = "0.2", features = ["meta-file"] }
/// ```
#[cfg(feature = "meta-file")]
#[macro_export]
macro_rules! include_field_metadata {
    () => {
        // Include the generated metadata file
        // This file is created by proto_convert_build::generate_proto_metadata()
        // Note: This only works when called from a crate that has run the build script
        include!(concat!(env!("OUT_DIR"), "/proto_field_metadata.rs"));
    };
}
