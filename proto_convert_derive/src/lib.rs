//! # proto_convert_derive
//!
//! Derive seamless conversions between `prost`-generated Protobuf types and custom Rust types.
//!
//! ## Overview
//!
//! `proto_convert_derive` is a procedural macro for automatically deriving
//! efficient, bidirectional conversions between Protobuf types generated by
//! [`prost`](https://github.com/tokio-rs/prost) and your native Rust structs.
//! This macro will significantly reduce boilerplate when you're working with
//! Protobufs.
//!
//! ## Features
//!
//! - **Automatic Bidirectional Conversion:** Derives `From<Proto>` and `Into<Proto>` implementations.
//! - **Primitive Type Support:** Direct mapping for Rust primitive types (`u32`, `i64`, `String`, etc.).
//! - **Option and Collections:** Supports optional fields (`Option<T>`) and collections (`Vec<T>`).
//! - **Newtype Wrappers:** Transparent conversions for single-field tuple structs.
//! - **Field Renaming:** Customize mapping between Rust and Protobuf field names using `#[proto(rename = "...")]`.
//! - **Custom Conversion Functions:** Handle complex scenarios with user-defined functions via `#[proto(derive_from_with = "...")]` and `#[proto(derive_into_with = "...")]`.
//! - **Ignored Fields:** Exclude fields from conversion using `#[proto(ignore)]`.
//! - **Configurable Protobuf Module:** Defaults to searching for types in a `proto` module, customizable per struct or globally.
//!
//! ## Usage
//!
//! Given Protobuf definitions compiled with `prost`:
//!
//! ```protobuf
//! syntax = "proto3";
//! package service;
//!
//! message Track {
//!     uint64 track_id = 1;
//! }
//!
//! message State {
//!     repeated Track tracks = 1;
//! }
//! ```
//!
//! Derive conversions in Rust:
//!
//! ```rust,ignore
//! use proto_convert_derive::ProtoConvert;
//! mod proto {
//!     tonic::include_proto!("service");
//! }
//!
//! #[derive(ProtoConvert)]
//! #[proto(module = "proto")]
//! pub struct Track {
//!     #[proto(transparent, rename = "track_id")]
//!     pub id: TrackId,
//! }
//!
//! #[derive(ProtoConvert)]
//! pub struct TrackId(u64);
//!
//! #[derive(ProtoConvert)]
//! pub struct State {
//!     pub tracks: Vec<Track>,
//! }
//! ```
//!
//! ### Complex conversions, akin to serde(deserialize_with = "..")
//!
//! ```rust,ignore
//! use std::collections::HashMap;
//!
//! #[derive(ProtoConvert)]
//! #[proto(rename = "State")]
//! pub struct StateMap {
//!     #[proto(derive_from_with = "into_map", derive_into_with = "from_map")]
//!     pub tracks: HashMap<TrackId, Track>,
//! }
//!
//! pub fn into_map(tracks: Vec<proto::Track>) -> HashMap<TrackId, Track> {
//!     tracks.into_iter().map(|t| (TrackId(t.track_id), t.into())).collect()
//! }
//!
//! pub fn from_map(tracks: HashMap<TrackId, Track>) -> Vec<proto::Track> {
//!     tracks.into_values().map(Into::into).collect()
//! }
//! ```
//!
//! ### Ignoring fields:
//!
//! ```rust,ignore
//! use std::sync::atomic::AtomicU64;
//!
//! #[derive(ProtoConvert)]
//! #[proto(rename = "State")]
//! pub struct ComplexState {
//!     pub tracks: Vec<Track>,
//!     #[proto(ignore)]
//!     pub counter: AtomicU64,
//! }
//! ```
//!
//! ### Handle enums
//!
//! ```protobuf
//! enum Status {
//!     STATUS_OK = 0;
//!     STATUS_MOVED_PERMANENTLY = 1;
//!     STATUS_FOUND = 2;
//!     STATUS_NOT_FOUND = 3;
//! }
//!
//! message StatusResponse {
//!     Status status = 1;
//!     string message = 2;
//! }
//!
//! enum AnotherStatus {
//!     OK = 0;
//!     MOVED_PERMANENTLY = 1;
//!     FOUND = 2;
//!     NOT_FOUND = 3;
//! }
//! ```
//!
//! ```rust,ignore
//! // We do not require to use the STATUS prefix!
//! #[derive(ProtoConvert)]
//! pub enum Status {
//!     Ok,
//!     MovedPermanently,
//!     Found,
//!     NotFound,
//! }
//!
//! #[derive(ProtoConvert)]
//! pub enum AnotherStatus {
//!     Ok,
//!     MovedPermanently,
//!     Found,
//!     NotFound,
//! }
//!
//! #[derive(ProtoConvert)]
//! pub struct StatusResponse {
//!     pub status: Status,
//!     pub message: String,
//! }
//! ```
//!
//! ## Limitations
//!
//! - Assumes Protobuf-generated types live in a single module.
//! - Optional Protobuf message fields (`optional`) use `.expect` and panic if missing; handle accordingly.
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::parse::Parser;
use syn::{self, Attribute, DeriveInput, Expr, Field, Lit, Meta, Type};
use syn::{punctuated::Punctuated, token::Comma};

#[proc_macro_derive(ProtoConvert, attributes(proto))]
pub fn proto_convert_derive(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    let name = &ast.ident;
    let proto_module = get_proto_module(&ast.attrs).unwrap_or_else(|| "proto".to_string());
    let proto_name = get_proto_struct_rename(&ast.attrs).unwrap_or_else(|| name.to_string());
    let proto_path =
        syn::parse_str::<syn::Path>(&format!("{}::{}", proto_module, proto_name)).unwrap();

    match &ast.data {
        syn::Data::Struct(data_struct) => {
            match &data_struct.fields {
                syn::Fields::Named(fields_named) => {
                    let fields = &fields_named.named;
                    let primitives = ["i32", "u32", "i64", "u64", "f32", "f64", "bool", "String"];
                    let from_proto_fields = fields.iter().map(|field| {
                        let field_name = field.ident.as_ref().unwrap();
                        if has_proto_ignore(field) {
                            quote! {
                                #field_name: Default::default()
                            }
                        } else {
                            let proto_field_ident = if let Some(rename) = get_proto_rename(field) {
                                syn::Ident::new(&rename, Span::call_site())
                            } else {
                                field_name.clone()
                            };
                            let field_type = &field.ty;
                            let is_transparent = has_transparent_attr(field);
                            let derive_from_with = get_proto_derive_from_with(field);

                            if let Some(from_with_path) = derive_from_with {
                                let from_with_path: syn::Path = syn::parse_str(&from_with_path).expect("Failed to parse derive_from_with path");
                                quote! {
                                    #field_name: #from_with_path(proto_struct.#proto_field_ident)
                                }
                            } else if is_transparent {
                                quote! {
                                    #field_name: <#field_type>::from(proto_struct.#proto_field_ident)
                                }
                            } else if is_option_type(field_type) {
                                let inner_type = get_inner_type_from_option(field_type).unwrap();
                                if is_vec_type(&inner_type) {
                                    quote! {
                                        #field_name: proto_struct.#proto_field_ident.into_iter().map(Into::into).collect()
                                    }
                                } else {
                                    quote! {
                                        #field_name: proto_struct.#proto_field_ident.map(Into::into)
                                    }
                                }
                            } else if is_vec_type(field_type) {
                                if let Some(inner_type) = get_inner_type_from_vec(field_type) {
                                    if is_proto_type_with_module(&inner_type, &proto_module) {
                                        quote! {
                                            #field_name: proto_struct.#proto_field_ident
                                        }
                                    } else {
                                        quote! {
                                            #field_name: proto_struct.#proto_field_ident.into_iter().map(Into::into).collect()
                                        }
                                    }
                                } else {
                                    quote! {
                                        #field_name: proto_struct.#proto_field_ident.into_iter().map(Into::into).collect()
                                    }
                                }
                            } else if let syn::Type::Path(type_path) = field_type {
                                let is_primitive = type_path.path.segments.len() == 1 &&
                                    primitives.iter().any(|&p| type_path.path.segments[0].ident == p);
                                let is_proto_type = type_path.path.segments.first()
                                    .is_some_and(|segment| segment.ident == proto_module.as_str());
                                if is_primitive {
                                    quote! { #field_name: proto_struct.#proto_field_ident }
                                } else if is_proto_type {
                                    quote! {
                                        #field_name: proto_struct.#proto_field_ident.expect(concat!("no ", stringify!(#proto_field_ident), " in proto"))
                                    }
                                } else {
                                    quote! {
                                        #field_name: #field_type::from(proto_struct.#proto_field_ident)
                                    }
                                }
                            } else {
                                panic!("Only path types are supported for field '{}'", field_name);
                            }
                        }
                    });

                    let from_my_fields = fields.iter().filter(|field| !has_proto_ignore(field)).map(|field| {
                        let field_name = field.ident.as_ref().unwrap();
                        let proto_field_ident = if let Some(rename) = get_proto_rename(field) {
                            syn::Ident::new(&rename, Span::call_site())
                        } else {
                            field_name.clone()
                        };
                        let field_type = &field.ty;
                        let is_transparent = has_transparent_attr(field);
                        let derive_into_with = get_proto_derive_into_with(field);

                        if let Some(into_with_path) = derive_into_with {
                            let into_with_path: syn::Path = syn::parse_str(&into_with_path).expect("Failed to parse derive_into_with path");
                            quote! {
                                #proto_field_ident: #into_with_path(my_struct.#field_name)
                            }
                        } else if is_transparent {
                            quote! {
                                #proto_field_ident: my_struct.#field_name.into()
                            }
                        } else if is_option_type(field_type) {
                            let inner_type = get_inner_type_from_option(field_type).unwrap();
                            if is_vec_type(&inner_type) {
                                quote! {
                                    #proto_field_ident: my_struct.#field_name.into_iter().map(Into::into).collect()
                                }
                            } else {
                                quote! {
                                    #proto_field_ident: my_struct.#field_name.map(Into::into)
                                }
                            }
                        } else if is_vec_type(field_type) {
                            if let Some(inner_type) = get_inner_type_from_vec(field_type) {
                                if is_proto_type_with_module(&inner_type, &proto_module) {
                                    quote! {
                                        #proto_field_ident: my_struct.#field_name
                                    }
                                } else {
                                    quote! {
                                        #proto_field_ident: my_struct.#field_name.into_iter().map(Into::into).collect()
                                    }
                                }
                            } else {
                                quote! {
                                    #proto_field_ident: my_struct.#field_name.into_iter().map(Into::into).collect()
                                }
                            }
                        } else if let syn::Type::Path(type_path) = field_type {
                            let is_primitive = type_path.path.segments.len() == 1
                                && primitives.iter().any(|&p| type_path.path.segments[0].ident == p);
                            let is_proto_type = type_path.path.segments.first()
                                .is_some_and(|segment| segment.ident == proto_module.as_str());
                            if is_primitive {
                                quote! { #proto_field_ident: my_struct.#field_name }
                            } else if is_proto_type {
                                quote! { #proto_field_ident: Some(my_struct.#field_name) }
                            } else {
                                quote! { #proto_field_ident: my_struct.#field_name.into() }
                            }
                        } else {
                            panic!("Only path types are supported for field '{}'", field_name);
                        }
                    });

                    let gen = quote! {
                        impl From<#proto_path> for #name {
                            fn from(proto_struct: #proto_path) -> Self {
                                Self {
                                    #(#from_proto_fields),*
                                }
                            }
                        }

                        impl From<#name> for #proto_path {
                            fn from(my_struct: #name) -> Self {
                                Self {
                                    #(#from_my_fields),*
                                }
                            }
                        }
                    };
                    gen.into()
                }
                syn::Fields::Unnamed(fields_unnamed) => {
                    if fields_unnamed.unnamed.len() != 1 {
                        panic!("ProtoConvert only supports tuple structs with exactly one field, found {}", fields_unnamed.unnamed.len());
                    }
                    let inner_type = &fields_unnamed.unnamed[0].ty;
                    let gen = quote! {
                        impl From<#inner_type> for #name {
                            fn from(value: #inner_type) -> Self {
                                #name(value)
                            }
                        }

                        impl From<#name> for #inner_type {
                            fn from(my: #name) -> Self {
                                my.0
                            }
                        }
                    };
                    gen.into()
                }
                syn::Fields::Unit => {
                    panic!("ProtoConvert does not support unit structs");
                }
            }
        }
        syn::Data::Enum(data_enum) => {
            let variants = &data_enum.variants;
            let from_i32_arms = variants.iter().enumerate().map(|(i, variant)| {
                let variant_ident = &variant.ident;
                let i_lit = syn::LitInt::new(&format!("{}i32", i), Span::call_site());
                quote! {
                    #i_lit => #name::#variant_ident,
                }
            });
            let into_i32_arms = variants.iter().enumerate().map(|(i, variant)| {
                let variant_ident = &variant.ident;
                let i_lit = syn::LitInt::new(&format!("{}i32", i), Span::call_site());
                quote! {
                    #name::#variant_ident => #i_lit,
                }
            });

            let proto_enum_path: syn::Path = syn::parse_str(&format!("{}::{}", proto_module, name))
                .expect("Failed to parse proto enum path");

            let gen = quote! {
                impl From<i32> for #name {
                    fn from(value: i32) -> Self {
                        match value {
                            #(#from_i32_arms)*
                            _ => panic!("Unknown enum value: {}", value),
                        }
                    }
                }

                impl From<#name> for i32 {
                    fn from(enum_val: #name) -> Self {
                        match enum_val {
                            #(#into_i32_arms)*
                        }
                    }
                }

                impl From<#name> for #proto_enum_path {
                    fn from(status: #name) -> Self {
                        let i32_val: i32 = status.into();
                        #proto_enum_path::try_from(i32_val).expect("Invalid status value")
                    }
                }

                impl From<#proto_enum_path> for #name {
                    fn from(proto_status: #proto_enum_path) -> Self {
                        let i32_val: i32 = proto_status.into();
                        #name::from(i32_val)
                    }
                }
            };
            gen.into()
        }
        _ => panic!("ProtoConvert only supports structs and enums, not unions"),
    }
}

fn is_option_type(ty: &Type) -> bool {
    if let Type::Path(type_path) = ty {
        if type_path.path.segments.len() == 1 && type_path.path.segments[0].ident == "Option" {
            return true;
        }
    }
    false
}

fn get_inner_type_from_option(ty: &Type) -> Option<Type> {
    if let Type::Path(type_path) = ty {
        if type_path.path.segments.len() == 1 && type_path.path.segments[0].ident == "Option" {
            if let syn::PathArguments::AngleBracketed(angle_bracketed) =
                &type_path.path.segments[0].arguments
            {
                if let Some(syn::GenericArgument::Type(inner_type)) = angle_bracketed.args.first() {
                    return Some(inner_type.clone());
                }
            }
        }
    }
    None
}

fn is_vec_type(ty: &Type) -> bool {
    if let Type::Path(type_path) = ty {
        if type_path.path.segments.len() == 1 && type_path.path.segments[0].ident == "Vec" {
            return true;
        }
    }
    false
}

fn get_inner_type_from_vec(ty: &Type) -> Option<Type> {
    if let Type::Path(type_path) = ty {
        if type_path.path.segments.len() == 1 && type_path.path.segments[0].ident == "Vec" {
            if let syn::PathArguments::AngleBracketed(angle_bracketed) =
                &type_path.path.segments[0].arguments
            {
                if let Some(syn::GenericArgument::Type(inner_type)) = angle_bracketed.args.first() {
                    return Some(inner_type.clone());
                }
            }
        }
    }
    None
}

fn is_proto_type_with_module(ty: &Type, proto_module: &str) -> bool {
    if let Type::Path(type_path) = ty {
        if let Some(segment) = type_path.path.segments.first() {
            return segment.ident == proto_module;
        }
    }
    false
}

fn get_proto_module(attrs: &[Attribute]) -> Option<String> {
    for attr in attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let nested_metas: Punctuated<Meta, Comma> = Punctuated::parse_terminated
                    .parse2(meta_list.tokens.clone())
                    .unwrap_or_else(|e| panic!("Failed to parse proto attribute: {}", e));
                for meta in nested_metas {
                    if let Meta::NameValue(meta_nv) = meta {
                        if meta_nv.path.is_ident("module") {
                            if let Expr::Lit(expr_lit) = meta_nv.value {
                                if let Lit::Str(lit_str) = expr_lit.lit {
                                    return Some(lit_str.value());
                                }
                            }
                            panic!("module value must be a string literal, e.g., #[proto(module = \"path\")]");
                        }
                    }
                }
            }
        }
    }
    None
}

fn get_proto_struct_rename(attrs: &[Attribute]) -> Option<String> {
    for attr in attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let nested_metas: Punctuated<Meta, Comma> = Punctuated::parse_terminated
                    .parse2(meta_list.tokens.clone())
                    .unwrap_or_else(|e| panic!("Failed to parse proto attribute: {}", e));
                for meta in nested_metas {
                    if let Meta::NameValue(meta_nv) = meta {
                        if meta_nv.path.is_ident("rename") {
                            if let Expr::Lit(expr_lit) = meta_nv.value {
                                if let Lit::Str(lit_str) = expr_lit.lit {
                                    return Some(lit_str.value());
                                }
                            }
                            panic!("rename value must be a string literal, e.g., #[proto(rename = \"...\")]");
                        }
                    }
                }
            }
        }
    }
    None
}

fn has_transparent_attr(field: &Field) -> bool {
    for attr in &field.attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let tokens = &meta_list.tokens;
                let token_str = quote!(#tokens).to_string();
                if token_str.contains("transparent") {
                    return true;
                }
            }
        }
    }
    false
}

fn get_proto_rename(field: &Field) -> Option<String> {
    for attr in &field.attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let nested_metas: Punctuated<Meta, Comma> = Punctuated::parse_terminated
                    .parse2(meta_list.tokens.clone())
                    .unwrap_or_else(|e| panic!("Failed to parse proto attribute: {}", e));
                for meta in nested_metas {
                    if let Meta::NameValue(meta_nv) = meta {
                        if meta_nv.path.is_ident("rename") {
                            if let Expr::Lit(expr_lit) = &meta_nv.value {
                                if let Lit::Str(lit_str) = &expr_lit.lit {
                                    return Some(lit_str.value());
                                }
                            }
                            panic!("rename value must be a string literal, e.g., rename = \"xyz\"");
                        }
                    }
                }
            }
        }
    }
    None
}

fn get_proto_derive_from_with(field: &Field) -> Option<String> {
    for attr in &field.attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let nested_metas: Punctuated<Meta, Comma> = Punctuated::parse_terminated
                    .parse2(meta_list.tokens.clone())
                    .unwrap_or_else(|e| panic!("Failed to parse proto attribute: {}", e));
                for meta in nested_metas {
                    if let Meta::NameValue(meta_nv) = meta {
                        if meta_nv.path.is_ident("derive_from_with") {
                            if let Expr::Lit(expr_lit) = &meta_nv.value {
                                if let Lit::Str(lit_str) = &expr_lit.lit {
                                    return Some(lit_str.value());
                                }
                            }
                            panic!("derive_from_with value must be a string literal, e.g., derive_from_with = \"path::to::function\"");
                        }
                    }
                }
            }
        }
    }
    None
}

fn get_proto_derive_into_with(field: &Field) -> Option<String> {
    for attr in &field.attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let nested_metas: Punctuated<Meta, Comma> = Punctuated::parse_terminated
                    .parse2(meta_list.tokens.clone())
                    .unwrap_or_else(|e| panic!("Failed to parse proto attribute: {}", e));
                for meta in nested_metas {
                    if let Meta::NameValue(meta_nv) = meta {
                        if meta_nv.path.is_ident("derive_into_with") {
                            if let Expr::Lit(expr_lit) = &meta_nv.value {
                                if let Lit::Str(lit_str) = &expr_lit.lit {
                                    return Some(lit_str.value());
                                }
                            }
                            panic!("derive_into_with value must be a string literal, e.g., derive_into_with = \"path::to::function\"");
                        }
                    }
                }
            }
        }
    }
    None
}

fn has_proto_ignore(field: &Field) -> bool {
    for attr in &field.attrs {
        if attr.path().is_ident("proto") {
            if let Meta::List(meta_list) = &attr.meta {
                let nested_metas: Punctuated<Meta, Comma> = Punctuated::parse_terminated
                    .parse2(meta_list.tokens.clone())
                    .unwrap_or_else(|e| panic!("Failed to parse proto attribute: {}", e));
                for meta in nested_metas {
                    if let Meta::Path(path) = meta {
                        if path.is_ident("ignore") {
                            return true;
                        }
                    }
                }
            }
        }
    }
    false
}
